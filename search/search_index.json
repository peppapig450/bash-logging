{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bashing Logs","text":"<p>A robust, production-ready logging utility library for Bash scripts with automatic error tracing, safe trap chaining, and zero-setup crash diagnostics.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>#!/usr/bin/env bash\nset -Eeuo pipefail\nsource ./logging.lib.sh\n\n# Initialize logging with your script name\nlogging::init \"$0\"\n\n# Now any error will be automatically logged with context\nlogging::log_info \"Starting deployment...\"\nlogging::log_warn \"Configuration file missing, using defaults\"\n\n# This will trigger the error trap with full diagnostics\nfalse  # Simulated error\n</code></pre> <p>Output:</p> <pre><code>[2025-06-10T04:24:11Z][INFO][deploy.sh] Starting deployment...\n[2025-06-10T04:24:11Z][WARN][deploy.sh] Configuration file missing, using defaults\n[2025-06-10T04:24:11Z][ERROR][deploy.sh] Unexpected fatal error in deploy.sh on line 8: false\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83c\udfa8 Color-coded output - Clear visual distinction between log levels</li> <li>\u23f0 UTC timestamps - ISO 8601 formatted for consistency</li> <li>\ud83d\udd0d Automatic error tracing - Zero-setup crash diagnostics with file, line, and command</li> <li>\ud83d\udd17 Safe trap chaining - Preserves existing ERR/EXIT handlers</li> <li>\ud83d\udee1\ufe0f Production-ready - Defensive programming and strict error handling</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code># Download the latest release\ncurl -fsLO https://raw.githubusercontent.com/peppapig450/bashing-logs/main/logging.lib.sh\n</code></pre> <pre><code># Source in your script\nsource ./logging.lib.sh\nlogging::init \"$0\"\n</code></pre> <p>Requirements: Bash 4.0+, standard Unix utilities, Perl</p>"},{"location":"#core-api","title":"Core API","text":"<pre><code># Initialization (enables automatic error tracing)\nlogging::init \"$0\"\n\n# Basic logging\nlogging::log_info \"Operation completed\"\nlogging::log_warn \"Retrying connection\"\nlogging::log_error \"Failed to connect\"\nlogging::log_fatal \"Critical error\" # Exits with status 1\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Getting Started - Installation, basic usage, and configuration</li> <li>API Reference - Complete function documentation</li> <li>Advanced Features - Trap chaining, error diagnostics, technical details</li> <li>Examples - Real-world usage patterns and best practices</li> <li>Contributing - Development guidelines and project standards</li> </ul>"},{"location":"#use-cases","title":"Use Cases","text":"<p>Perfect for:</p> <ul> <li>CI/CD pipelines - Clear timestamped logs with automatic error reporting</li> <li>System administration - Robust error handling and diagnostic information</li> <li>Application deployment - Script coordination with proper error tracing</li> <li>Development tooling - Consistent logging across build and utility scripts</li> <li>Anything else - This works well with any Bash script in general</li> </ul> <p>Need help? Check the documentation or open an issue.</p>"},{"location":"advanced-features/","title":"Advanced Features","text":"<p>Deep dive into the sophisticated features that make Bashing Logs production-ready.</p>"},{"location":"advanced-features/#safe-trap-chaining","title":"Safe Trap Chaining","text":"<p>One of the most sophisticated features of this library is its ability to safely chain with existing trap handlers. Most logging libraries simply overwrite existing traps, breaking error handling in complex scripts.</p>"},{"location":"advanced-features/#the-problem-with-traditional-approaches","title":"The Problem with Traditional Approaches","text":"<p>Bash trap syntax is notoriously difficult to parse correctly:</p> <pre><code># Simple trap\ntrap 'echo \"error\"' ERR\n\n# Complex trap with quotes and special characters  \ntrap 'echo \"Error in $0\"; cleanup || true' ERR\n\n# Multiple commands with different quoting\ntrap 'cleanup; notify_admin \"Script failed\"; exit 1' ERR\n</code></pre> <p>Traditional approaches fail because they:</p> <ul> <li>Use fragile regex that breaks on special characters</li> <li>Don't handle nested quotes properly</li> <li>Overwrite existing functionality instead of chaining</li> </ul>"},{"location":"advanced-features/#the-solution-perl-based-parsing","title":"The Solution: Perl-Based Parsing","text":"<p>This library uses Perl to safely parse existing trap output:</p> <pre><code>perl -lne '\n    if (/^trap -- '\\''([^'\\'']*)'\\'' ERR$/) {\n        print \"$1\"\n    }\n'\n</code></pre> <p>This regex precisely extracts commands from <code>trap -p</code> output by:</p> <ul> <li>Matching the exact <code>trap --</code> format</li> <li>Handling escaped single quotes within commands</li> <li>Preserving spaces and special characters</li> <li>Supporting multiple commands separated by semicolons</li> </ul>"},{"location":"advanced-features/#chaining-process","title":"Chaining Process","text":"<ol> <li>Extract existing trap: Parse current ERR/EXIT trap using Perl</li> <li>Validate command: Ensure the extracted command is safe to chain</li> <li>Create new trap: Combine existing command with library handler</li> <li>Install safely: Set the new compound trap</li> </ol> <pre><code># Before: existing trap\ntrap 'cleanup_database' ERR\n\n# After: chained trap\ntrap 'cleanup_database; logging::trap_err_handler' ERR\n</code></pre>"},{"location":"advanced-features/#chaining-examples","title":"Chaining Examples","text":"<p>Single existing command:</p> <pre><code># Original\ntrap 'cleanup' ERR\n\n# After logging::add_err_trap\ntrap 'cleanup; logging::trap_err_handler' ERR\n</code></pre> <p>Multiple existing commands:</p> <pre><code># Original  \ntrap 'cleanup; notify_admin; exit 1' ERR\n\n# After logging::add_err_trap\ntrap 'cleanup; notify_admin; exit 1; logging::trap_err_handler' ERR\n</code></pre> <p>Complex commands with quotes:</p> <pre><code># Original\ntrap 'echo \"Failed in $0\" | logger' ERR\n\n# After logging::add_err_trap  \ntrap 'echo \"Failed in $0\" | logger; logging::trap_err_handler' ERR\n</code></pre>"},{"location":"advanced-features/#zero-setup-error-diagnostics","title":"Zero-Setup Error Diagnostics","text":"<p>After calling <code>logging::init</code>, any command failure automatically provides detailed diagnostics.</p>"},{"location":"advanced-features/#what-gets-logged","title":"What Gets Logged","text":"<p>For every error, the trap handler captures:</p> <ol> <li>Source file: Which script encountered the error</li> <li>Line number: Exact line where the failure occurred  </li> <li>Failed command: The command that caused the error</li> <li>Context: Script name and timestamp</li> </ol>"},{"location":"advanced-features/#error-context-variables","title":"Error Context Variables","text":"<p>The trap handler uses these Bash built-in arrays:</p> <pre><code>${BASH_SOURCE[1]}   # Source file of the error\n${BASH_LINENO[0]}   # Line number of the error\n${BASH_COMMAND}     # The command that failed\n</code></pre>"},{"location":"advanced-features/#example-diagnostic-output","title":"Example Diagnostic Output","text":"<pre><code># Script: deploy.sh, line 42\nrsync -av /source/ /nonexistent/\n\n# Automatic output:\n[2024-12-15T10:30:47Z][ERROR][deploy.sh] Unexpected fatal error in deploy.sh on line 42: rsync -av /source/ /nonexistent/\n</code></pre>"},{"location":"advanced-features/#error-scenarios-covered","title":"Error Scenarios Covered","text":"<p>Command not found:</p> <pre><code>nonexistent_command arg1 arg2\n# Output: Unexpected fatal error in script.sh on line 15: nonexistent_command arg1 arg2\n</code></pre> <p>File operation failures:</p> <pre><code>cp /protected/file /destination/\n# Output: Unexpected fatal error in script.sh on line 23: cp /protected/file /destination/\n</code></pre> <p>Pipeline failures (with <code>set -o pipefail</code>):</p> <pre><code>cat missing_file | grep pattern\n# Output: Unexpected fatal error in script.sh on line 31: cat missing_file | grep pattern\n</code></pre>"},{"location":"advanced-features/#technical-implementation-details","title":"Technical Implementation Details","text":""},{"location":"advanced-features/#shell-detection","title":"Shell Detection","text":"<p>The library includes robust shell detection to ensure Bash compatibility:</p> <pre><code>_detect_shell() {\n  # First try /proc filesystem (Linux)\n  if [ -r \"/proc/$$/exe\" ]; then\n    basename \"$(readlink /proc/$$/exe)\"\n  # Fall back to ps command (macOS, BSD)\n  else\n    basename \"$(ps -p $$ -o comm= 2&gt;/dev/null)\"\n  fi\n}\n</code></pre> <p>Detection methods:</p> <ul> <li>Linux: Uses <code>/proc/$$/exe</code> symlink to current executable</li> <li>macOS/BSD: Uses <code>ps</code> with process ID to get command name</li> <li>Fallback: Returns \"unknown\" if both methods fail</li> </ul>"},{"location":"advanced-features/#source-only-execution","title":"Source-Only Execution","text":"<p>Prevents accidental direct execution of the library:</p> <pre><code>(return 0 2&gt;/dev/null) || {\n    printf \"This script is meant to be sourced, not executed.\\n\" &gt;&amp;2\n    exit 1\n}\n</code></pre> <p>How it works:</p> <ul> <li><code>return</code> succeeds only when sourced (not executed)</li> <li><code>2&gt;/dev/null</code> suppresses error output in execution context</li> <li>Parentheses create subshell to isolate the test</li> </ul>"},{"location":"advanced-features/#strict-mode-compatibility","title":"Strict Mode Compatibility","text":"<p>Designed to work seamlessly with Bash strict mode:</p> <pre><code>set -Eeuo pipefail\n</code></pre> <p>Compatibility features:</p> <ul> <li><code>-e</code> (errexit): Library functions handle errors gracefully</li> <li><code>-E</code> (errtrace): ERR trap inheritance works with chaining</li> <li><code>-u</code> (nounset): All variables are properly initialized</li> <li><code>-o pipefail</code>: Pipeline failures are caught by error traps</li> </ul>"},{"location":"advanced-features/#color-detection-and-handling","title":"Color Detection and Handling","text":"<p>Automatic color detection based on output destination:</p> <pre><code># Colors enabled when:\n# - Output is to a terminal (tty)\n# - Terminal supports ANSI escape sequences\n# - Not running in CI (unless explicitly enabled)\n\n# Colors disabled when:\n# - Output redirected to file\n# - Terminal doesn't support colors\n# - Running in non-interactive environment\n</code></pre>"},{"location":"advanced-features/#performance-considerations","title":"Performance Considerations","text":""},{"location":"advanced-features/#timestamp-generation","title":"Timestamp Generation","text":"<p>Each log call executes <code>date -u</code>:</p> <ul> <li>Cost: ~1-5ms per call on modern systems</li> <li>Alternative: Could cache for microsecond precision, but adds complexity</li> <li>Trade-off: Accuracy vs. performance (accuracy chosen)</li> </ul>"},{"location":"advanced-features/#trap-parsing-overhead","title":"Trap Parsing Overhead","text":"<p>Perl parsing for trap chaining:</p> <ul> <li>When: Only during initialization (<code>logging::init</code>)</li> <li>Cost: ~10-50ms one-time setup cost</li> <li>Frequency: Once per script execution</li> <li>Alternative: Shell-only parsing (fragile and error-prone)</li> </ul>"},{"location":"advanced-features/#memory-usage","title":"Memory Usage","text":"<p>Global variables used:</p> <ul> <li><code>LOGGING_SCRIPT_NAME</code>: Script basename (~10-50 bytes)</li> <li>Function definitions: ~2-4KB total</li> <li>No persistent buffers or caches</li> </ul>"},{"location":"advanced-features/#integration-patterns","title":"Integration Patterns","text":""},{"location":"advanced-features/#library-integration","title":"Library Integration","text":"<p>For libraries that want to use logging without forcing initialization:</p> <pre><code># In your library\nmy_library::function() {\n    # Check if logging is available\n    if declare -F logging::log_info &gt;/dev/null 2&gt;&amp;1; then\n        logging::log_info \"Library operation completed\"\n    fi\n}\n</code></pre>"},{"location":"advanced-features/#multi-script-coordination","title":"Multi-Script Coordination","text":"<p>For scripts that call other scripts:</p> <pre><code># main.sh\n#!/usr/bin/env bash\nsource ./logging.lib.sh\nlogging::init \"$0\"\n\nlogging::log_info \"Starting batch process\"\n\n# Child scripts inherit the library\nfor script in process-*.sh; do\n    # Each script can have its own logging::init call\n    ./\"$script\"\ndone\n</code></pre>"},{"location":"advanced-features/#cicd-pipeline-integration","title":"CI/CD Pipeline Integration","text":"<p>For continuous integration environments:</p> <pre><code># In your CI script\nsource ./logging.lib.sh\nlogging::init \"ci-pipeline\"\n\n# All output is properly timestamped and level-coded\nlogging::log_info \"Starting build process\"\nmake build 2&gt;&amp;1 | while read -r line; do\n    logging::log_info \"BUILD: $line\"\ndone\n</code></pre>"},{"location":"advanced-features/#debugging-and-troubleshooting","title":"Debugging and Troubleshooting","text":""},{"location":"advanced-features/#debug-mode","title":"Debug Mode","text":"<p>Enable debug output to see trap chaining:</p> <pre><code># Set before sourcing library\nexport LOGGING_DEBUG=1\nsource ./logging.lib.sh\n</code></pre>"},{"location":"advanced-features/#common-issues","title":"Common Issues","text":"<p>Trap not working:</p> <pre><code># Check if strict mode is enabled\nset -E  # Ensure ERR trap inheritance\n\n# Verify trap installation\ntrap -p ERR\n</code></pre> <p>Color issues:</p> <pre><code># Force colors in CI\nexport TERM=xterm-256color\n\n# Disable colors entirely\nexport NO_COLOR=1\n</code></pre> <p>Performance concerns:</p> <pre><code># For high-frequency logging, consider batching\n{\n    echo \"Message 1\"\n    echo \"Message 2\"  \n    echo \"Message 3\"\n} | while read -r msg; do\n    logging::log_info \"$msg\"\ndone\n</code></pre>"},{"location":"advanced-features/#security-considerations","title":"Security Considerations","text":""},{"location":"advanced-features/#command-injection","title":"Command Injection","text":"<p>The library is designed to prevent command injection:</p> <ul> <li>All user input is properly quoted</li> <li>No <code>eval</code> or dynamic command construction</li> <li>Perl parsing uses safe regex patterns</li> </ul>"},{"location":"advanced-features/#information-disclosure","title":"Information Disclosure","text":"<p>Error messages may reveal:</p> <ul> <li>File paths and script names</li> <li>Command arguments (potentially sensitive)</li> <li>System usernames (in paths)</li> </ul> <p>Mitigation: Review error messages before production deployment.</p>"},{"location":"advanced-features/#privilege-escalation","title":"Privilege Escalation","text":"<p>The library doesn't:</p> <ul> <li>Create files or directories</li> <li>Modify system configuration</li> <li>Execute arbitrary commands</li> <li>Require special privileges</li> </ul>"},{"location":"advanced-features/#extending-the-library","title":"Extending the Library","text":""},{"location":"advanced-features/#custom-log-levels","title":"Custom Log Levels","text":"<p>Add new log levels by extending the color mapping:</p> <pre><code># Add to logging::log function\ncase \"${level}\" in\n    INFO) color=$'\\033[0;32m' ;;\n    WARN) color=$'\\033[0;33m' ;;\n    ERROR) color=$'\\033[0;31m' ;;\n    DEBUG) color=$'\\033[0;36m' ;;  # Cyan\n    TRACE) color=$'\\033[0;37m' ;;  # Gray\n    *)\n        printf \"Invalid log level: %s\\n\" \"${level}\"\n        exit 1\n        ;;\nesac\n\n# Add convenience function\nlogging::log_debug() { logging::log DEBUG \"$@\"; }\n</code></pre>"},{"location":"advanced-features/#custom-formatters","title":"Custom Formatters","text":"<p>Override the logging format:</p> <pre><code># Custom timestamp format\nlogging::custom_timestamp() {\n    date '+%Y-%m-%d %H:%M:%S'\n}\n\n# Override in logging::log function\nts=\"$(logging::custom_timestamp)\"\n</code></pre>"},{"location":"advanced-features/#integration-hooks","title":"Integration Hooks","text":"<p>Add hooks for external log aggregation:</p> <pre><code>logging::log() {\n    # ... existing implementation ...\n\n    # Send to external system (optional)\n    if command -v logger &gt;/dev/null 2&gt;&amp;1; then\n        logger -t \"${LOGGING_SCRIPT_NAME:-script}\" \"${level}: $*\"\n    fi\n}\n</code></pre>"},{"location":"api-reference/","title":"API Reference","text":"<p>Complete documentation for all functions provided by the Bashing Logs library.</p>"},{"location":"api-reference/#core-logging-functions","title":"Core Logging Functions","text":""},{"location":"api-reference/#logginglog_info-message","title":"<code>logging::log_info MESSAGE</code>","text":"<p>Logs an informational message with green color coding.</p> <p>Parameters:</p> <ul> <li><code>MESSAGE</code>: The message to log (can contain spaces)</li> </ul> <p>Example:</p> <pre><code>logging::log_info \"Database connection established\"\nlogging::log_info \"Processing file: $filename\"\n</code></pre> <p>Output:</p> <pre><code>[2025-06-10T04:24:11Z][INFO][script.sh] Database connection established\n</code></pre>"},{"location":"api-reference/#logginglog_warn-message","title":"<code>logging::log_warn MESSAGE</code>","text":"<p>Logs a warning message with yellow color coding.</p> <p>Parameters:</p> <ul> <li><code>MESSAGE</code>: The warning message to log</li> </ul> <p>Example:</p> <pre><code>logging::log_warn \"Configuration file not found, using defaults\"\nlogging::log_warn \"API rate limit approaching: $remaining_calls remaining\"\n</code></pre> <p>Output:</p> <pre><code>[2025-06-10T04:24:11Z][WARN][script.sh] Configuration file not found, using defaults\n</code></pre>"},{"location":"api-reference/#logginglog_error-message","title":"<code>logging::log_error MESSAGE</code>","text":"<p>Logs an error message with red color coding. Does not exit the script.</p> <p>Parameters:</p> <ul> <li><code>MESSAGE</code>: The error message to log</li> </ul> <p>Example:</p> <pre><code>logging::log_error \"Failed to connect to database after 3 attempts\"\nlogging::log_error \"Invalid configuration in section: $section_name\"\n</code></pre> <p>Output:</p> <pre><code>[2025-06-10T04:24:11Z][ERROR][script.sh] Failed to connect to database after 3 attempts\n</code></pre>"},{"location":"api-reference/#logginglog_fatal-message","title":"<code>logging::log_fatal MESSAGE</code>","text":"<p>Logs an error message with red color coding and exits the script with status 1.</p> <p>Parameters:</p> <ul> <li><code>MESSAGE</code>: The fatal error message to log</li> </ul> <p>Example:</p> <pre><code>logging::log_fatal \"Critical dependency missing: $required_tool\"\nlogging::log_fatal \"Unable to acquire exclusive lock\"\n</code></pre> <p>Output:</p> <pre><code>[2025-06-10T04:24:11Z][ERROR][script.sh] Critical dependency missing: docker\n</code></pre> <p>Note: The script will exit immediately after logging.</p>"},{"location":"api-reference/#initialization-functions","title":"Initialization Functions","text":""},{"location":"api-reference/#logginginit-script_name","title":"<code>logging::init SCRIPT_NAME</code>","text":"<p>Initializes the logging system with automatic error trapping and cleanup.</p> <p>Parameters:</p> <ul> <li><code>SCRIPT_NAME</code>: Name to use in log prefixes (typically <code>$0</code>)</li> </ul> <p>Behavior:</p> <ul> <li>Sets the global <code>LOGGING_SCRIPT_NAME</code> variable</li> <li>Installs error trap handler for automatic crash diagnostics</li> <li>Sets up cleanup handler for script exit</li> <li>Safely chains with any existing ERR/EXIT traps</li> </ul> <p>Example:</p> <pre><code>#!/usr/bin/env bash\nsource ./logging.lib.sh\n\n# Initialize logging (recommended as early as possible)\nlogging::init \"$0\"\n\n# Now any command failure will be automatically logged\nfalse  # This will trigger the error trap\n</code></pre> <p>Output:</p> <pre><code>[2025-06-10T04:24:11Z][ERROR][script.sh] Unexpected fatal error in script.sh on line 7: false\n</code></pre>"},{"location":"api-reference/#advanced-trap-functions","title":"Advanced Trap Functions","text":""},{"location":"api-reference/#loggingadd_err_trap","title":"<code>logging::add_err_trap</code>","text":"<p>Manually adds the error trap handler without full initialization.</p> <p>Use Case: When you want error trapping but not the full initialization (e.g., in libraries or when you need custom setup).</p> <p>Example:</p> <pre><code># Add only error trapping\nlogging::add_err_trap\n\n# Set script name manually if desired\nLOGGING_SCRIPT_NAME=\"custom-name\"\n</code></pre> <p>Note: Called automatically by <code>logging::init</code>.</p>"},{"location":"api-reference/#loggingadd_exit_trap","title":"<code>logging::add_exit_trap</code>","text":"<p>Manually adds the cleanup handler for script exit.</p> <p>Use Case: When you need custom cleanup behavior or want to add cleanup without error trapping.</p> <p>Example:</p> <pre><code># Add only exit cleanup\nlogging::add_exit_trap\n</code></pre> <p>Note: Called automatically by <code>logging::init</code>.</p>"},{"location":"api-reference/#loggingsetup_traps","title":"<code>logging::setup_traps</code>","text":"<p>Sets up both ERR and EXIT traps. Equivalent to calling both <code>logging::add_err_trap</code> and <code>logging::add_exit_trap</code>.</p> <p>Example:</p> <pre><code># Manual trap setup (without setting script name)\nlogging::setup_traps\n</code></pre> <p>Note: Called automatically by <code>logging::init</code>.</p>"},{"location":"api-reference/#internal-functions","title":"Internal Functions","text":"<p>These functions are used internally but may be useful for advanced use cases.</p>"},{"location":"api-reference/#logginglog-level-message","title":"<code>logging::log LEVEL MESSAGE</code>","text":"<p>Internal function used by all logging functions. Handles timestamp generation, color coding, and formatting.</p> <p>Parameters:</p> <ul> <li><code>LEVEL</code>: Log level (INFO, WARN, ERROR)</li> <li><code>MESSAGE</code>: Message to log</li> </ul> <p>Example:</p> <pre><code># Generally you should use the specific functions instead\nlogging::log INFO \"This is equivalent to logging::log_info\"\nlogging::log WARN \"This is equivalent to logging::log_warn\"\n</code></pre>"},{"location":"api-reference/#loggingtrap_err_handler","title":"<code>logging::trap_err_handler</code>","text":"<p>The actual error trap handler function. Logs fatal errors with context and exits.</p> <p>Use Case: Advanced trap customization.</p> <p>Example:</p> <pre><code># Custom trap that does additional cleanup\ntrap 'cleanup_function; logging::trap_err_handler' ERR\n</code></pre>"},{"location":"api-reference/#loggingcleanup","title":"<code>logging::cleanup</code>","text":"<p>Cleanup function that unsets global logging state.</p> <p>Use Case: Manual cleanup or custom exit handling.</p> <p>Example:</p> <pre><code># Manual cleanup\nlogging::cleanup\n</code></pre>"},{"location":"api-reference/#global-variables","title":"Global Variables","text":""},{"location":"api-reference/#logging_script_name","title":"<code>LOGGING_SCRIPT_NAME</code>","text":"<p>Global variable that stores the script name for log prefixing.</p> <p>Set by: <code>logging::init</code> Type: String Scope: Global export</p> <p>Example:</p> <pre><code># Set automatically\nlogging::init \"$0\"\necho \"Script name: $LOGGING_SCRIPT_NAME\"\n\n# Or set manually\nLOGGING_SCRIPT_NAME=\"my-custom-script\"\nlogging::log_info \"This will show [my-custom-script] in the log\"\n</code></pre>"},{"location":"api-reference/#function-naming-convention","title":"Function Naming Convention","text":"<p>All functions follow the <code>namespace::function</code> convention from the Google Shell Style Guide:</p> <ul> <li>Namespace: <code>logging::</code></li> <li>Purpose: Prevents naming conflicts with other libraries</li> <li>Consistency: All functions are prefixed, making them easy to identify</li> </ul>"},{"location":"api-reference/#error-handling","title":"Error Handling","text":""},{"location":"api-reference/#return-codes","title":"Return Codes","text":"<ul> <li>Logging functions: Always return 0 (success)</li> <li><code>logging::log_fatal</code>: Exits with code 1</li> <li><code>logging::init</code>: Returns 1 if called with wrong number of arguments</li> </ul>"},{"location":"api-reference/#error-scenarios","title":"Error Scenarios","text":"<p>Invalid log level:</p> <pre><code>logging::log INVALID \"message\"  # Will exit with error\n</code></pre> <p>Missing arguments:</p> <pre><code>logging::init  # Returns 1 and logs warning\n</code></pre> <p>Shell compatibility:</p> <pre><code># If not running in Bash, library will fail to load\n#!/bin/sh\nsource ./logging.lib.sh  # Will exit with error message\n</code></pre>"},{"location":"api-reference/#output-specifications","title":"Output Specifications","text":""},{"location":"api-reference/#timestamp-format","title":"Timestamp Format","text":"<ul> <li>Format: ISO 8601/RFC3339 UTC (<code>YYYY-MM-DDTHH:MM:SSZ</code>)</li> <li>Timezone: Always UTC for consistency across systems</li> <li>Example: <code>2025-06-10T04:24:11Z</code></li> </ul>"},{"location":"api-reference/#color-codes","title":"Color Codes","text":"<p>When outputting to a terminal:</p> <ul> <li>INFO: <code>\\033[0;32m</code> (green)</li> <li>WARN: <code>\\033[0;33m</code> (yellow)  </li> <li>ERROR: <code>\\033[0;31m</code> (red)</li> <li>Reset: <code>\\033[0m</code></li> </ul> <p>Colors are automatically disabled when:</p> <ul> <li>Output is redirected to a file</li> <li>Terminal doesn't support colors</li> <li>Running in non-interactive mode</li> </ul>"},{"location":"api-reference/#output-destination","title":"Output Destination","text":"<p>All logging output goes to stderr (file descriptor 2), following Unix conventions for diagnostic output.</p>"},{"location":"api-reference/#thread-safety","title":"Thread Safety","text":"<p>The logging functions are not thread-safe. If using in multi-process environments:</p> <ul> <li>Each process will have its own logging state</li> <li>Multiple processes writing to the same log file may interleave output</li> <li>Consider using process-specific log files or external log aggregation</li> </ul>"},{"location":"api-reference/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Timestamp generation: Calls <code>date</code> command for each log entry</li> <li>Color detection: Minimal overhead, cached per session</li> <li>Script name resolution: Done once during initialization</li> <li>Trap parsing: Uses Perl, minimal overhead during setup</li> </ul> <p>For high-frequency logging, consider buffering messages or using dedicated logging solutions.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to Bashing Logs! This document provides guidelines for contributing to the project.</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<ul> <li>Bash 4.0+ (for testing the library)</li> <li>Perl (for trap parsing functionality)</li> <li>Git (for version control)</li> <li>ShellCheck (for static analysis)</li> <li>Bats (for testing - optional but recommended)</li> </ul>"},{"location":"contributing/#setup-instructions","title":"Setup Instructions","text":"<ol> <li>Fork and clone the repository:</li> </ol> <p><code>bash    git clone https://github.com/peppapig450/bashing-logs.git    cd bashing-logs</code></p> <ol> <li>Install development tools:</li> </ol> <p>```bash    # Install ShellCheck    # Ubuntu/Debian    sudo apt-get install shellcheck shfmt bats</p> <p># macOS    brew install shellcheck shfmt bats    ```</p> <ol> <li>Verify setup:</li> </ol> <p>```bash    # Test the library    bash -c \"source ./logging.lib.sh; logging::log_info 'Test message'\"</p> <p># Run ShellCheck    shellcheck logging.lib.sh    ```</p>"},{"location":"contributing/#code-standards","title":"Code Standards","text":""},{"location":"contributing/#shell-style-guide","title":"Shell Style Guide","text":"<p>This project follows the Google Shell Style Guide with these specific conventions:</p>"},{"location":"contributing/#function-naming","title":"Function Naming","text":"<p>All functions must use the <code>namespace::function</code> convention:</p> <pre><code># \u2713 Correct\nlogging::log_info() { ... }\nlogging::init() { ... }\n\n# \u2717 Incorrect\nlog_info() { ... }\ninit_logging() { ... }\n</code></pre>"},{"location":"contributing/#variable-naming","title":"Variable Naming","text":"<ul> <li>Global variables: <code>UPPER_CASE</code> with namespace prefix when appropriate</li> <li>Local variables: <code>lower_case</code></li> <li>Constants: <code>readonly UPPER_CASE</code></li> </ul> <pre><code># Global variables\ndeclare -g LOGGING_SCRIPT_NAME\nreadonly LOGGING_VERSION=\"1.0.0\"\n\n# Local variables\nlogging::init() {\n    local script_name=\"$1\"\n    local config_file=\"config.yml\"\n}\n</code></pre>"},{"location":"contributing/#error-handling","title":"Error Handling","text":"<ul> <li>Always use <code>set -Eeuo pipefail</code> for strict error handling</li> <li>Provide meaningful error messages</li> <li>Use appropriate exit codes</li> </ul> <pre><code># \u2713 Good error handling\nif [[ ! -f \"$config_file\" ]]; then\n    logging::log_fatal \"Configuration file not found: $config_file\"\nfi\n\n# \u2717 Poor error handling\n[[ -f \"$config_file\" ]] || exit 1\n</code></pre>"},{"location":"contributing/#code-formatting","title":"Code Formatting","text":""},{"location":"contributing/#indentation-and-spacing","title":"Indentation and Spacing","text":"<ul> <li>Indentation: 2 spaces (no tabs)</li> <li>Line length: Maximum 80 characters where practical</li> <li>Function spacing: One blank line between functions</li> </ul> <pre><code># \u2713 Correct formatting\nlogging::log_info() {\n  local message=\"$*\"\n  logging::log INFO \"$message\"\n}\n\nlogging::log_warn() {\n  local message=\"$*\"\n  logging::log WARN \"$message\"\n}\n</code></pre>"},{"location":"contributing/#quoting","title":"Quoting","text":"<ul> <li>Quote variables to prevent word splitting: <code>\"$variable\"</code></li> <li>Use single quotes for literal strings: <code>'literal text'</code></li> <li>Use <code>$()</code> for command substitution, not backticks</li> </ul> <pre><code># \u2713 Correct quoting\nlocal timestamp=\"$(date -u +\"%Y-%m-%dT%H:%M:%SZ\")\"\nlocal message=\"Processing file: $filename\"\n\n# \u2717 Incorrect quoting\nlocal timestamp=`date -u +%Y-%m-%dT%H:%M:%SZ`\nlocal message=Processing file: $filename\n</code></pre>"},{"location":"contributing/#documentation-standards","title":"Documentation Standards","text":""},{"location":"contributing/#function-documentation","title":"Function Documentation","text":"<p>All public functions must include documentation:</p> <pre><code># logging::init SCRIPT_NAME\n# Initializes the logging system with automatic error trapping.\n#\n# Sets the global LOGGING_SCRIPT_NAME variable and installs\n# error handlers for comprehensive crash diagnostics.\n#\n# Arguments:\n#   SCRIPT_NAME - Name to use in log prefixes (typically $0)\n#\n# Usage:\n#   logging::init \"$0\"\nlogging::init() {\n    # Implementation...\n}\n</code></pre>"},{"location":"contributing/#comment-style","title":"Comment Style","text":"<ul> <li>Use <code>#</code> for single-line comments</li> <li>Use <code># ===</code> for section headers</li> <li>Explain complex logic and non-obvious decisions</li> </ul> <pre><code># ==============================================================================\n# Trap handling functions\n# ==============================================================================\n\n# Extract existing ERR trap command using Perl for safe parsing.\n# We use Perl because shell quoting rules are complex and error-prone\n# when parsing trap output that may contain special characters.\nexisting=\"$(perl -lne '...' &lt;&lt;&lt; \"$(trap -p ERR)\" || true)\"\n</code></pre>"},{"location":"contributing/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"contributing/#manual-testing","title":"Manual Testing","text":"<p>Before submitting changes, test your modifications:</p> <pre><code># Create test script\ncat &gt; test_changes.sh &lt;&lt; 'EOF'\n#!/usr/bin/env bash\nset -Eeuo pipefail\n\nsource ./logging.lib.sh\nlogging::init \"$0\"\n\n# Test basic logging\nlogging::log_info \"Testing info message\"\nlogging::log_warn \"Testing warning message\"\nlogging::log_error \"Testing error message\"\n\n# Test error trapping\necho \"About to trigger error trap...\"\nfalse  # This should be caught and logged\nEOF\n\nchmod +x test_changes.sh\n./test_changes.sh\n</code></pre>"},{"location":"contributing/#automated-testing","title":"Automated Testing","text":"<p>If you have Bats installed, run the test suite:</p> <pre><code># Run all tests\nbats tests/\n\n# Run specific test file\nbats tests/logging_test.bats\n</code></pre>"},{"location":"contributing/#testing-checklist","title":"Testing Checklist","text":"<ul> <li>[ ] All log levels work correctly</li> <li>[ ] Error trapping functions properly</li> <li>[ ] Trap chaining preserves existing handlers</li> <li>[ ] Script name prefixing works</li> <li>[ ] Color output appears correctly in terminals</li> <li>[ ] No colors when redirected to files</li> <li>[ ] Compatible with <code>set -Eeuo pipefail</code></li> <li>[ ] No ShellCheck warnings</li> <li>[ ] Works on different shells (Bash 4.0+)</li> </ul>"},{"location":"contributing/#contribution-process","title":"Contribution Process","text":""},{"location":"contributing/#1-issue-first","title":"1. Issue First","text":"<p>For significant changes, please open an issue first to discuss:</p> <ul> <li>New features or enhancements</li> <li>Breaking changes</li> <li>Performance improvements</li> <li>Documentation restructuring</li> </ul>"},{"location":"contributing/#2-branch-naming","title":"2. Branch Naming","text":"<p>Use descriptive branch names:</p> <pre><code># Feature branches\ngit checkout -b feature/add-debug-level\ngit checkout -b feature/json-output-format\n\n# Bug fixes\ngit checkout -b fix/trap-chaining-quotes\ngit checkout -b fix/color-detection-ci\n\n# Documentation\ngit checkout -b docs/api-reference-update\ngit checkout -b docs/examples-expansion\n</code></pre>"},{"location":"contributing/#3-commit-messages","title":"3. Commit Messages","text":"<p>Follow conventional commit format:</p> <pre><code>type(scope): description\n\n- feat: new features\n- fix: bug fixes\n- docs: documentation changes\n- style: formatting changes\n- refactor: code restructuring\n- test: adding or updating tests\n- chore: maintenance tasks\n\nExamples:\nfeat(logging): add support for custom log levels\nfix(traps): handle complex quoting in existing traps\ndocs(examples): add CI/CD pipeline examples\n</code></pre>"},{"location":"contributing/#4-pull-request-process","title":"4. Pull Request Process","text":"<ol> <li>Update documentation if you've changed functionality</li> <li>Add tests for new features</li> <li>Run ShellCheck and fix any warnings</li> <li>Test manually with the provided test scripts</li> <li>Update CHANGELOG.md if applicable</li> </ol>"},{"location":"contributing/#pull-request-template","title":"Pull Request Template","text":"<p>When creating a PR, include:</p> <pre><code>## Description\nBrief description of the changes\n\n## Type of Change\n- [ ] Bug fix\n- [ ] New feature\n- [ ] Documentation update\n- [ ] Performance improvement\n\n## Testing\n- [ ] Manual testing completed\n- [ ] ShellCheck passes\n- [ ] Existing functionality unaffected\n\n## Checklist\n- [ ] Code follows style guidelines\n- [ ] Self-review completed\n- [ ] Documentation updated\n- [ ] No breaking changes (or clearly marked)\n</code></pre>"},{"location":"contributing/#project-standards","title":"Project Standards","text":""},{"location":"contributing/#backward-compatibility","title":"Backward Compatibility","text":"<ul> <li>Maintain API stability: Existing function signatures should not change</li> <li>Deprecation process: Mark old features as deprecated before removal</li> <li>Version semantic: Follow semantic versioning (MAJOR.MINOR.PATCH)</li> </ul>"},{"location":"contributing/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Minimize external commands: Each <code>date</code> call adds ~1-5ms overhead</li> <li>Avoid unnecessary work: Don't parse traps if not needed</li> <li>Memory efficiency: Clean up temporary variables</li> </ul>"},{"location":"contributing/#security-guidelines","title":"Security Guidelines","text":"<ul> <li>Input validation: Validate all user inputs</li> <li>No command injection: Properly quote all variables</li> <li>Safe defaults: Fail securely when possible</li> <li>Minimal privileges: Don't require elevated permissions</li> </ul>"},{"location":"contributing/#release-process","title":"Release Process","text":""},{"location":"contributing/#version-numbering","title":"Version Numbering","text":"<p>Follow semantic versioning:</p> <ul> <li>MAJOR: Breaking changes to public API</li> <li>MINOR: New features, backward compatible</li> <li>PATCH: Bug fixes, backward compatible</li> </ul>"},{"location":"contributing/#release-checklist","title":"Release Checklist","text":"<ol> <li>Update version numbers in relevant files</li> <li>Update CHANGELOG.md with release notes</li> <li>Tag the release with <code>git tag vX.Y.Z</code></li> <li>Create GitHub release with release notes</li> <li>Update documentation if needed</li> </ol>"},{"location":"contributing/#getting-help","title":"Getting Help","text":""},{"location":"contributing/#communication-channels","title":"Communication Channels","text":"<ul> <li>GitHub Issues: Bug reports and feature requests</li> <li>Pull Request Reviews: Code-specific feedback</li> </ul>"},{"location":"contributing/#recognition","title":"Recognition","text":"<p>Contributors are recognized in:</p> <ul> <li>CONTRIBUTORS.md file</li> <li>Release notes for significant contributions</li> <li>Git history with proper attribution</li> </ul>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":"<p>All contributions are valued:</p> <ul> <li>Code contributions: Features, bug fixes, improvements</li> <li>Documentation: Examples, guides, API docs</li> <li>Testing: Test cases, bug reports, compatibility testing</li> <li>Community: Answering questions, code reviews</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>This project follows a code of conduct based on respect and inclusivity:</p>"},{"location":"contributing/#our-pledge","title":"Our Pledge","text":"<p>We pledge to make participation in our project a harassment-free experience for everyone, regardless of background or identity.</p>"},{"location":"contributing/#standards","title":"Standards","text":"<ul> <li>Respectful communication: Be kind and professional</li> <li>Constructive feedback: Focus on code and ideas, not individuals</li> <li>Inclusive language: Avoid terminology that could exclude others</li> <li>Collaborative approach: Work together toward common goals</li> </ul>"},{"location":"contributing/#enforcement","title":"Enforcement","text":"<p>Issues can be reported to project maintainers. All reports will be reviewed and investigated promptly.</p> <p>Thank you for contributing to Bashing Logs! Your efforts help make Bash scripting more robust and maintainable for everyone.</p>"},{"location":"examples/","title":"Examples","text":"<p>Real-world usage patterns and best practices for the Bashing Logs library.</p>"},{"location":"examples/#basic-usage-patterns","title":"Basic Usage Patterns","text":""},{"location":"examples/#simple-script-template","title":"Simple Script Template","text":"<pre><code>#!/usr/bin/env bash\nset -Eeuo pipefail\n\n# Load and initialize logging\nsource ./logging.lib.sh\nlogging::init \"$0\"\n\nmain() {\n    logging::log_info \"Script started with arguments: $*\"\n\n    # Your script logic here\n    process_data \"$@\"\n\n    logging::log_info \"Script completed successfully\"\n}\n\nprocess_data() {\n    logging::log_info \"Processing data files...\"\n\n    for file in \"$@\"; do\n        if [[ -f \"$file\" ]]; then\n            logging::log_info \"Processing: $file\"\n            # Process file\n        else\n            logging::log_warn \"File not found: $file\"\n        fi\n    done\n}\n\n# Run main function\nmain \"$@\"\n</code></pre>"},{"location":"examples/#error-handling-patterns","title":"Error Handling Patterns","text":"<pre><code>#!/usr/bin/env bash\nsource ./logging.lib.sh\nlogging::init \"$0\"\n\n# Pattern 1: Continue on error\nattempt_operation() {\n    if ! risky_command; then\n        logging::log_error \"Operation failed, but continuing\"\n        return 1\n    fi\n    logging::log_info \"Operation successful\"\n}\n\n# Pattern 2: Retry with backoff\nretry_operation() {\n    local max_attempts=3\n    local delay=1\n\n    for attempt in $(seq 1 $max_attempts); do\n        logging::log_info \"Attempt $attempt/$max_attempts\"\n\n        if command_that_might_fail; then\n            logging::log_info \"Operation succeeded on attempt $attempt\"\n            return 0\n        fi\n\n        if [[ $attempt -lt $max_attempts ]]; then\n            logging::log_warn \"Attempt $attempt failed, retrying in ${delay}s\"\n            sleep $delay\n            delay=$((delay * 2))  # Exponential backoff\n        fi\n    done\n\n    logging::log_fatal \"Operation failed after $max_attempts attempts\"\n}\n\n# Pattern 3: Graceful degradation\noptional_operation() {\n    if ! optional_command; then\n        logging::log_warn \"Optional operation failed, using fallback\"\n        fallback_command\n    fi\n}\n</code></pre>"},{"location":"examples/#cicd-pipeline-examples","title":"CI/CD Pipeline Examples","text":""},{"location":"examples/#github-actions-integration","title":"GitHub Actions Integration","text":"<pre><code>#!/usr/bin/env bash\n# .github/scripts/build.sh\nset -Eeuo pipefail\n\nsource \"$(dirname \"$0\")/../../lib/logging.lib.sh\"\nlogging::init \"github-build\"\n\nbuild_application() {\n    logging::log_info \"Starting build process\"\n    logging::log_info \"Node version: $(node --version)\"\n    logging::log_info \"NPM version: $(npm --version)\"\n\n    logging::log_info \"Installing dependencies...\"\n    npm ci || logging::log_fatal \"Failed to install dependencies\"\n\n    logging::log_info \"Running linter...\"\n    npm run lint || logging::log_fatal \"Linting failed\"\n\n    logging::log_info \"Running tests...\"\n    if ! npm test; then\n        logging::log_error \"Tests failed\"\n        logging::log_info \"Uploading test artifacts...\"\n        # Upload test results even on failure\n        upload_test_results\n        exit 1\n    fi\n\n    logging::log_info \"Building application...\"\n    npm run build || logging::log_fatal \"Build failed\"\n\n    logging::log_info \"Build completed successfully\"\n}\n\nupload_test_results() {\n    if [[ -d \"test-results\" ]]; then\n        logging::log_info \"Uploading test results to artifacts\"\n        # GitHub Actions artifact upload logic\n    fi\n}\n\nbuild_application\n</code></pre>"},{"location":"examples/#docker-build-pipeline","title":"Docker Build Pipeline","text":"<pre><code>#!/usr/bin/env bash\n# scripts/docker-build.sh\nset -Eeuo pipefail\n\nsource ./logging.lib.sh\nlogging::init \"docker-build\"\n\nreadonly IMAGE_NAME=\"${1:-myapp}\"\nreadonly TAG=\"${2:-latest}\"\nreadonly DOCKERFILE=\"${3:-Dockerfile}\"\n\nbuild_docker_image() {\n    logging::log_info \"Building Docker image: $IMAGE_NAME:$TAG\"\n    logging::log_info \"Using Dockerfile: $DOCKERFILE\"\n\n    # Check prerequisites\n    command -v docker &gt;/dev/null || logging::log_fatal \"Docker not found\"\n    [[ -f \"$DOCKERFILE\" ]] || logging::log_fatal \"Dockerfile not found: $DOCKERFILE\"\n\n    # Build with progress logging\n    logging::log_info \"Starting Docker build...\"\n    if docker build -t \"$IMAGE_NAME:$TAG\" -f \"$DOCKERFILE\" . 2&gt;&amp;1 | \\\n       while IFS= read -r line; do\n           logging::log_info \"DOCKER: $line\"\n       done; then\n        logging::log_info \"Docker build successful\"\n    else\n        logging::log_fatal \"Docker build failed\"\n    fi\n\n    # Verify image\n    if docker image inspect \"$IMAGE_NAME:$TAG\" &gt;/dev/null 2&gt;&amp;1; then\n        local size\n        size=$(docker image inspect \"$IMAGE_NAME:$TAG\" --format='{{.Size}}' | numfmt --to=iec)\n        logging::log_info \"Image created successfully, size: $size\"\n    else\n        logging::log_fatal \"Image verification failed\"\n    fi\n}\n\nbuild_docker_image\n</code></pre>"},{"location":"examples/#system-administration-scripts","title":"System Administration Scripts","text":""},{"location":"examples/#backup-script","title":"Backup Script","text":"<pre><code>#!/usr/bin/env bash\nset -Eeuo pipefail\n\nsource ./logging.lib.sh\nlogging::init \"backup-script\"\n\nreadonly BACKUP_SOURCE=\"${1:-/var/www}\"\nreadonly BACKUP_DEST=\"${2:-/backup/$(date +%Y%m%d)}\"\nreadonly RETENTION_DAYS=\"${3:-30}\"\n\nperform_backup() {\n    logging::log_info \"Starting backup process\"\n    logging::log_info \"Source: $BACKUP_SOURCE\"\n    logging::log_info \"Destination: $BACKUP_DEST\"\n\n    # Pre-backup checks\n    check_prerequisites\n    create_backup_directory\n\n    # Perform backup\n    logging::log_info \"Creating backup...\"\n    local start_time\n    start_time=$(date +%s)\n\n    if rsync -av --progress \"$BACKUP_SOURCE/\" \"$BACKUP_DEST/\" 2&gt;&amp;1 | \\\n       while IFS= read -r line; do\n           # Log rsync progress (simplified)\n           if [[ \"$line\" =~ ^[0-9]+% ]]; then\n               logging::log_info \"Progress: $line\"\n           fi\n       done; then\n        local end_time duration\n        end_time=$(date +%s)\n        duration=$((end_time - start_time))\n        logging::log_info \"Backup completed in ${duration}s\"\n    else\n        logging::log_fatal \"Backup failed\"\n    fi\n\n    # Post-backup tasks\n    verify_backup\n    cleanup_old_backups\n\n    logging::log_info \"Backup process completed successfully\"\n}\n\ncheck_prerequisites() {\n    logging::log_info \"Checking prerequisites...\"\n\n    [[ -d \"$BACKUP_SOURCE\" ]] || logging::log_fatal \"Source directory not found: $BACKUP_SOURCE\"\n    command -v rsync &gt;/dev/null || logging::log_fatal \"rsync not found\"\n\n    # Check available space\n    local available_space\n    available_space=$(df \"$(dirname \"$BACKUP_DEST\")\" | awk 'NR==2 {print $4}')\n    if [[ $available_space -lt 1000000 ]]; then  # Less than 1GB\n        logging::log_warn \"Low disk space: ${available_space}KB available\"\n    fi\n}\n\ncreate_backup_directory() {\n    if [[ ! -d \"$BACKUP_DEST\" ]]; then\n        logging::log_info \"Creating backup directory: $BACKUP_DEST\"\n        mkdir -p \"$BACKUP_DEST\" || logging::log_fatal \"Failed to create backup directory\"\n    fi\n}\n\nverify_backup() {\n    logging::log_info \"Verifying backup integrity...\"\n\n    local source_count backup_count\n    source_count=$(find \"$BACKUP_SOURCE\" -type f | wc -l)\n    backup_count=$(find \"$BACKUP_DEST\" -type f | wc -l)\n\n    if [[ $source_count -eq $backup_count ]]; then\n        logging::log_info \"Backup verification successful: $backup_count files\"\n    else\n        logging::log_error \"Backup verification failed: $source_count source files, $backup_count backup files\"\n    fi\n}\n\ncleanup_old_backups() {\n    logging::log_info \"Cleaning up backups older than $RETENTION_DAYS days...\"\n\n    local base_dir\n    base_dir=$(dirname \"$BACKUP_DEST\")\n\n    find \"$base_dir\" -type d -name \"????????\" -mtime +$RETENTION_DAYS | while read -r old_backup; do\n        logging::log_info \"Removing old backup: $old_backup\"\n        rm -rf \"$old_backup\"\n    done\n}\n\nperform_backup\n</code></pre>"},{"location":"examples/#service-deployment-script","title":"Service Deployment Script","text":"<pre><code>#!/usr/bin/env bash\nset -Eeuo pipefail\n\nsource ./logging.lib.sh\nlogging::init \"deploy-service\"\n\nreadonly SERVICE_NAME=\"${1:?Service name required}\"\nreadonly VERSION=\"${2:?Version required}\"\nreadonly ENVIRONMENT=\"${3:-staging}\"\n\ndeploy_service() {\n    logging::log_info \"Deploying $SERVICE_NAME v$VERSION to $ENVIRONMENT\"\n\n    # Pre-deployment checks\n    validate_environment\n    check_service_health\n\n    # Deployment steps\n    backup_current_version\n    download_new_version\n    update_configuration\n    restart_service\n    verify_deployment\n\n    logging::log_info \"Deployment completed successfully\"\n}\n\nvalidate_environment() {\n    logging::log_info \"Validating deployment environment...\"\n\n    case \"$ENVIRONMENT\" in\n        staging|production)\n            logging::log_info \"Deploying to $ENVIRONMENT environment\"\n            ;;\n        *)\n            logging::log_fatal \"Invalid environment: $ENVIRONMENT\"\n            ;;\n    esac\n\n    # Check if service exists\n    if ! systemctl list-units --full --all | grep -q \"$SERVICE_NAME\"; then\n        logging::log_fatal \"Service not found: $SERVICE_NAME\"\n    fi\n}\n\ncheck_service_health() {\n    logging::log_info \"Checking current service health...\"\n\n    if systemctl is-active --quiet \"$SERVICE_NAME\"; then\n        logging::log_info \"Service is currently running\"\n\n        # Check service endpoint if available\n        if curl -sf \"http://localhost:8080/health\" &gt;/dev/null 2&gt;&amp;1; then\n            logging::log_info \"Service health check passed\"\n        else\n            logging::log_warn \"Service health check failed, proceeding anyway\"\n        fi\n    else\n        logging::log_warn \"Service is not currently running\"\n    fi\n}\n\nbackup_current_version() {\n    logging::log_info \"Backing up current version...\"\n\n    local backup_dir=\"/backup/deployments/$(date +%Y%m%d_%H%M%S)\"\n    mkdir -p \"$backup_dir\"\n\n    cp -r \"/opt/$SERVICE_NAME\" \"$backup_dir/\" || {\n        logging::log_error \"Backup failed, but continuing deployment\"\n    }\n}\n\ndownload_new_version() {\n    logging::log_info \"Downloading version $VERSION...\"\n\n    local download_url=\"https://releases.example.com/$SERVICE_NAME/$VERSION.tar.gz\"\n    local temp_file=\"/tmp/$SERVICE_NAME-$VERSION.tar.gz\"\n\n    if curl -L -o \"$temp_file\" \"$download_url\"; then\n        logging::log_info \"Download completed\"\n\n        # Verify checksum if available\n        if curl -sf \"${download_url}.sha256\" &gt;/dev/null 2&gt;&amp;1; then\n            logging::log_info \"Verifying checksum...\"\n            cd \"$(dirname \"$temp_file\")\"\n            curl -L \"${download_url}.sha256\" | sha256sum -c || logging::log_fatal \"Checksum verification failed\"\n        fi\n\n        # Extract\n        logging::log_info \"Extracting archive...\"\n        tar -xzf \"$temp_file\" -C \"/opt/\" || logging::log_fatal \"Extraction failed\"\n        rm \"$temp_file\"\n    else\n        logging::log_fatal \"Download failed: $download_url\"\n    fi\n}\n\nupdate_configuration() {\n    logging::log_info \"Updating configuration...\"\n\n    local config_file=\"/opt/$SERVICE_NAME/config.yml\"\n    if [[ -f \"$config_file.template\" ]]; then\n        envsubst &lt; \"$config_file.template\" &gt; \"$config_file\"\n        logging::log_info \"Configuration updated from template\"\n    fi\n}\n\nrestart_service() {\n    logging::log_info \"Restarting service...\"\n\n    systemctl restart \"$SERVICE_NAME\" || logging::log_fatal \"Failed to restart service\"\n\n    # Wait for service to be ready\n    local attempts=30\n    while [[ $attempts -gt 0 ]]; do\n        if systemctl is-active --quiet \"$SERVICE_NAME\"; then\n            logging::log_info \"Service started successfully\"\n            return 0\n        fi\n        logging::log_info \"Waiting for service to start... ($attempts attempts remaining)\"\n        sleep 2\n        ((attempts--))\n    done\n\n    logging::log_fatal \"Service failed to start within timeout\"\n}\n\nverify_deployment() {\n    logging::log_info \"Verifying deployment...\"\n\n    # Check service status\n    systemctl status \"$SERVICE_NAME\" --no-pager || true\n\n    # Check application health\n    sleep 5  # Give app time to initialize\n    if curl -sf \"http://localhost:8080/health\" &gt;/dev/null 2&gt;&amp;1; then\n        logging::log_info \"Health check passed\"\n    else\n        logging::log_error \"Health check failed\"\n        systemctl stop \"$SERVICE_NAME\"\n        logging::log_fatal \"Deployment verification failed\"\n    fi\n\n    # Check version endpoint\n    local reported_version\n    if reported_version=$(curl -sf \"http://localhost:8080/version\" 2&gt;/dev/null); then\n        if [[ \"$reported_version\" == \"$VERSION\" ]]; then\n            logging::log_info \"Version verification passed: $reported_version\"\n        else\n            logging::log_warn \"Version mismatch: expected $VERSION, got $reported_version\"\n        fi\n    fi\n}\n\ndeploy_service\n</code></pre>"},{"location":"examples/#multi-script-coordination","title":"Multi-Script Coordination","text":""},{"location":"examples/#orchestration-script","title":"Orchestration Script","text":"<pre><code>#!/usr/bin/env bash\nset -Eeuo pipefail\n\nsource ./logging.lib.sh\nlogging::init \"orchestrator\"\n\nreadonly SCRIPTS_DIR=\"./scripts\"\nreadonly PARALLEL_JOBS=3\n\nrun_pipeline() {\n    logging::log_info \"Starting pipeline orchestration\"\n\n    # Phase 1: Preparation (sequential)\n    run_phase \"preparation\" \"prepare-environment.sh\" \"download-dependencies.sh\"\n\n    # Phase 2: Processing (parallel)\n    run_phase_parallel \"processing\" \"process-data-1.sh\" \"process-data-2.sh\" \"process-data-3.sh\"\n\n    # Phase 3: Cleanup (sequential)\n    run_phase \"cleanup\" \"generate-reports.sh\" \"cleanup-temp.sh\"\n\n    logging::log_info \"Pipeline completed successfully\"\n}\n\nrun_phase() {\n    local phase_name=\"$1\"\n    shift\n\n    logging::log_info \"Starting phase: $phase_name\"\n\n    for script in \"$@\"; do\n        run_script \"$script\"\n    done\n\n    logging::log_info \"Phase completed: $phase_name\"\n}\n\nrun_phase_parallel() {\n    local phase_name=\"$1\"\n    shift\n\n    logging::log_info \"Starting parallel phase: $phase_name\"\n\n    # Create temporary directory for job tracking\n    local job_dir\n    job_dir=$(mktemp -d)\n    local -a pids=()\n\n    # Start jobs\n    for script in \"$@\"; do\n        (\n            run_script \"$script\"\n            echo $? &gt; \"$job_dir/$(basename \"$script\").exit\"\n        ) &amp;\n        pids+=($!)\n\n        # Limit concurrent jobs\n        if [[ ${#pids[@]} -ge $PARALLEL_JOBS ]]; then\n            wait_for_job pids \"$job_dir\"\n        fi\n    done\n\n    # Wait for remaining jobs\n    while [[ ${#pids[@]} -gt 0 ]]; do\n        wait_for_job pids \"$job_dir\"\n    done\n\n    # Check all exit codes\n    local failed_scripts=()\n    for script in \"$@\"; do\n        local exit_file=\"$job_dir/$(basename \"$script\").exit\"\n        if [[ -f \"$exit_file\" ]]; then\n            local exit_code\n            exit_code=$(cat \"$exit_file\")\n            if [[ $exit_code -ne 0 ]]; then\n                failed_scripts+=(\"$script\")\n            fi\n        fi\n    done\n\n    rm -rf \"$job_dir\"\n\n    if [[ ${#failed_scripts[@]} -gt 0 ]]; then\n        logging::log_fatal \"Failed scripts in $phase_name: ${failed_scripts[*]}\"\n    fi\n\n    logging::log_info \"Parallel phase completed: $phase_name\"\n}\n\nwait_for_job() {\n    local -n pids_ref=$1\n    local job_dir=\"$2\"\n\n    # Wait for first job to complete\n    wait \"${pids_ref[0]}\"\n\n    # Remove completed job from array\n    pids_ref=(\"${pids_ref[@]:1}\")\n}\n\nrun_script() {\n    local script=\"$1\"\n    local script_path=\"$SCRIPTS_DIR/$script\"\n\n    if [[ ! -f \"$script_path\" ]]; then\n        logging::log_fatal \"Script not found: $script_path\"\n    fi\n\n    if [[ ! -x \"$script_path\" ]]; then\n        logging::log_fatal \"Script not executable: $script_path\"\n    fi\n\n    logging::log_info \"Executing: $script\"\n\n    # Execute script with timeout\n    if timeout 300 \"$script_path\" 2&gt;&amp;1 | while IFS= read -r line; do\n        logging::log_info \"[$script] $line\"\n    done; then\n        logging::log_info \"Script completed: $script\"\n    else\n        local exit_code=${PIPESTATUS[0]}\n        if [[ $exit_code -eq 124 ]]; then\n            logging::log_error \"Script timed out: $script\"\n        else\n            logging::log_error \"Script failed with exit code $exit_code: $script\"\n        fi\n        return $exit_code\n    fi\n}\n\nrun_pipeline\n</code></pre>"},{"location":"examples/#best-practices-examples","title":"Best Practices Examples","text":""},{"location":"examples/#error-recovery-and-resilience","title":"Error Recovery and Resilience","text":"<pre><code>#!/usr/bin/env bash\nset -Eeuo pipefail\n\nsource ./logging.lib.sh\nlogging::init \"resilient-script\"\n\n# Circuit breaker pattern\ndeclare -g FAILURE_COUNT=0\ndeclare -g MAX_FAILURES=5\ndeclare -g CIRCUIT_OPEN=false\n\ncall_external_service() {\n    if [[ \"$CIRCUIT_OPEN\" == \"true\" ]]; then\n        logging::log_warn \"Circuit breaker open, skipping service call\"\n        return 1\n    fi\n\n    if external_service_call; then\n        # Reset on success\n        FAILURE_COUNT=0\n        logging::log_info \"Service call successful\"\n        return 0\n    else\n        ((FAILURE_COUNT++))\n        logging::log_error \"Service call failed (failure count: $FAILURE_COUNT)\"\n\n        if [[ $FAILURE_COUNT -ge $MAX_FAILURES ]]; then\n            CIRCUIT_OPEN=true\n            logging::log_warn \"Circuit breaker opened after $MAX_FAILURES failures\"\n        fi\n        return 1\n    fi\n}\n\n# Graceful degradation\nprocess_with_fallback() {\n    local data=\"$1\"\n\n    if ! primary_processor \"$data\"; then\n        logging::log_warn \"Primary processor failed, trying secondary\"\n\n        if ! secondary_processor \"$data\"; then\n            logging::log_warn \"Secondary processor failed, using basic fallback\"\n            basic_processor \"$data\"\n        fi\n    fi\n}\n\n# Resource cleanup\ncleanup_resources() {\n    logging::log_info \"Cleaning up resources...\"\n\n    # Remove temporary files\n    if [[ -n \"${TEMP_DIR:-}\" &amp;&amp; -d \"$TEMP_DIR\" ]]; then\n        rm -rf \"$TEMP_DIR\"\n        logging::log_info \"Removed temporary directory: $TEMP_DIR\"\n    fi\n\n    # Close file descriptors\n    exec 3&gt;&amp;- 2&gt;/dev/null || true\n    exec 4&gt;&amp;- 2&gt;/dev/null || true\n\n    # Kill background processes\n    if [[ -n \"${BG_PID:-}\" ]]; then\n        kill \"$BG_PID\" 2&gt;/dev/null || true\n        logging::log_info \"Terminated background process: $BG_PID\"\n    fi\n}\n\n# Install cleanup trap\ntrap cleanup_resources EXIT\n</code></pre>"},{"location":"examples/#configuration-and-environment-management","title":"Configuration and Environment Management","text":"<pre><code>#!/usr/bin/env bash\nset -Eeuo pipefail\n\nsource ./logging.lib.sh\nlogging::init \"config-manager\"\n\n# Configuration loading with validation\nload_configuration() {\n    local config_file=\"${1:-config.env}\"\n\n    if [[ ! -f \"$config_file\" ]]; then\n        logging::log_fatal \"Configuration file not found: $config_file\"\n    fi\n\n    logging::log_info \"Loading configuration from: $config_file\"\n\n    # Source configuration\n    set -a  # Export all variables\n    source \"$config_file\"\n    set +a\n\n    # Validate required variables\n    validate_required_config\n\n    # Log configuration (without sensitive values)\n    log_configuration\n}\n\nvalidate_required_config() {\n    local required_vars=(\n        \"DATABASE_URL\"\n        \"API_KEY\"\n        \"SERVICE_PORT\"\n        \"LOG_LEVEL\"\n    )\n\n    logging::log_info \"Validating configuration...\"\n\n    for var in \"${required_vars[@]}\"; do\n        if [[ -z \"${!var:-}\" ]]; then\n            logging::log_fatal \"Required configuration missing: $var\"\n        fi\n    done\n\n    # Validate specific formats\n    if [[ ! \"$SERVICE_PORT\" =~ ^[0-9]+$ ]] || [[ \"$SERVICE_PORT\" -lt 1 || \"$SERVICE_PORT\" -gt 65535 ]]; then\n        logging::log_fatal \"Invalid SERVICE_PORT: $SERVICE_PORT\"\n    fi\n\n    if [[ ! \"$LOG_LEVEL\" =~ ^(DEBUG|INFO|WARN|ERROR)$ ]]; then\n        logging::log_fatal \"Invalid LOG_LEVEL: $LOG_LEVEL\"\n    fi\n\n    logging::log_info \"Configuration validation passed\"\n}\n\nlog_configuration() {\n    logging::log_info \"Active configuration:\"\n    logging::log_info \"  SERVICE_PORT=$SERVICE_PORT\"\n    logging::log_info \"  LOG_LEVEL=$LOG_LEVEL\"\n    logging::log_info \"  DATABASE_URL=${DATABASE_URL/password=*/password=***}\"\n    logging::log_info \"  API_KEY=${API_KEY:0:8}...\"\n}\n\n# Environment-specific handling\nsetup_environment() {\n    local environment=\"${ENVIRONMENT:-development}\"\n\n    case \"$environment\" in\n        development)\n            export DEBUG=true\n            export LOG_LEVEL=DEBUG\n            logging::log_info \"Development environment configured\"\n            ;;\n        staging)\n            export DEBUG=false\n            export LOG_LEVEL=INFO\n            logging::log_info \"Staging environment configured\"\n            ;;\n        production)\n            export DEBUG=false\n            export LOG_LEVEL=WARN\n            logging::log_info \"Production environment configured\"\n            ;;\n        *)\n            logging::log_fatal \"Unknown environment: $environment\"\n            ;;\n    esac\n}\n</code></pre> <p>These examples demonstrate production-ready patterns that leverage the full power of the Bashing Logs library, from simple scripts to complex orchestration systems.</p>"},{"location":"getting-started/","title":"Getting started","text":"<p>This guide will help you install and configure the Bashing Logs library in your Bash scripts.</p>"},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#basic-installation","title":"Basic Installation","text":"<p>Simply download and source the library:</p> <pre><code># Download the library\ncurl -fsLO https://raw.githubusercontent.com/peppapig450/bashing-logs/main/logging.lib.sh\n</code></pre> <p>Include this in your script:</p> <pre><code>source ./logging.lib.sh\n</code></pre>"},{"location":"getting-started/#project-integration","title":"Project Integration","text":"<p>For projects with multiple scripts, place <code>logging.lib.sh</code> in a common location:</p> <pre><code>project/\n\u251c\u2500\u2500 lib/\n\u2502   \u2514\u2500\u2500 logging.lib.sh\n\u251c\u2500\u2500 scripts/\n\u2502   \u251c\u2500\u2500 deploy.sh\n\u2502   \u2514\u2500\u2500 backup.sh\n\u2514\u2500\u2500 README.md\n</code></pre> <p>Then source with a relative path:</p> <pre><code>#!/usr/bin/env bash\nSOURCE_DIR=\"$(cd -Pe -- \"$(dirname -- \"${BASH_SOURCE[0]}\")\" &amp;&amp; echo \"${PWD}\")\"\nsource \"${SOURCE_DIR}/../lib/logging.lib.sh\"\n</code></pre>"},{"location":"getting-started/#requirements","title":"Requirements","text":""},{"location":"getting-started/#system-requirements","title":"System Requirements","text":"<ul> <li>Bash 4.0+ (automatically checked at runtime)</li> <li>Standard Unix utilities: <code>date</code>, <code>basename</code>, <code>realpath</code></li> <li>Perl (for safe trap parsing)</li> </ul>"},{"location":"getting-started/#compatibility","title":"Compatibility","text":"<p>The library is tested and works on:</p> <ul> <li>Linux (all major distros except Alpine)</li> <li>macOS</li> <li>Windows (via WSL/Cygwin)</li> <li>CI environments (Github Actions, Gitlab CI, Jenkins)</li> </ul>"},{"location":"getting-started/#basic-setup","title":"Basic Setup","text":""},{"location":"getting-started/#minimal-example","title":"Minimal Example","text":"<pre><code>#!/usr/bin/env bash\nsource ./logging.lib.sh\n\nlogging::log_info \"Script started\"\nlogging::log_warn \"This is a warning\"\nlogging::log_error \"This is an error\"\n</code></pre>"},{"location":"getting-started/#recommended-setup","title":"Recommended Setup","text":"<p>For production scripts, use this template:</p> <pre><code>#!/usr/bin/env bash\nset -Eeuo pipefail # Strict mode\n\n# Source the logging library\nsource ./logging.lib.sh\n\n# Initialize with automatic error trapping\nlogging::init \"$0\"\n\n# Your script logic here\nmain() {\n    logging::log_info \"Starting main process\"\n    # ... your code ...\n    logging::log_info \"Process completed successfully!\"\n}\n\n# Run main function\nmain \"$@\"\n</code></pre>"},{"location":"getting-started/#configuration","title":"Configuration","text":""},{"location":"getting-started/#script-name","title":"Script Name","text":"<p>The library can automatically prefix logs with your script name:</p> <pre><code># Initialize with script name\nlogging::init \"$0\"\n</code></pre> <p>Or set it manually:</p> <pre><code>logging::init \"my-lovely-script\"\n</code></pre> <p>This produces logs like:</p> <pre><code>[2025-06-10T04:24:11Z][INFO][my-lovely-script] Hello world!\n</code></pre>"},{"location":"getting-started/#strict-mode-compatibility","title":"Strict Mode Compatibility","text":"<p>The library is designed to work with Bash strict mode:</p> <pre><code>set -Eeuo pipefail\n</code></pre> <p>This combination provides:</p> <ul> <li><code>-e</code>: Exit on any command failure</li> <li><code>-E</code>: ERR trace inheritance</li> <li><code>-u</code>: Error on undefined</li> <li><code>-o</code>: Pipeline failure detection</li> </ul> <p>Without <code>set -E</code> automatic error tracing will not work in functions or subshells.</p>"},{"location":"getting-started/#understanding-the-output","title":"Understanding the output","text":""},{"location":"getting-started/#log-format","title":"Log Format","text":"<p>All logs follow this structure:</p> <pre><code>[TIMESTAMP][LEVEL][SCRIPT_NAME] MESSAGE\n</code></pre> <ul> <li>TIMESTAMP: UTC time in ISO 8601/RFC3339 format (<code>YYYY-MM-DDTHH:MM:SSZ</code>)</li> <li>LEVEL: <code>INFO</code>, <code>WARN</code>, or <code>ERROR</code></li> <li>SCRIPT_NAME: Your script's basename (optional)</li> <li>MESSAGE: Your log content</li> </ul>"},{"location":"getting-started/#color-coding","title":"Color Coding","text":"<p>When outputting to a terminal:</p> <ul> <li>INFO: Green text</li> <li>WARN: Yellow text</li> <li>ERROR: Red text</li> </ul> <p>Colors are automatically disabled when redirecting to files or in non-interactive environments.</p>"},{"location":"getting-started/#output-destination","title":"Output Destination","text":"<p>All logs go to stderr (standard error), following Unix conventions. This allows you to:</p> <pre><code># Separate logs from script output\n./script.sh &gt; output.txt 2&gt; logs.txt\n\n# Or combine them\n./script.sh &gt; combined.txt 2&gt;&amp;1\n</code></pre>"},{"location":"getting-started/#error-handling","title":"Error Handling","text":""},{"location":"getting-started/#automatic-error-trapping","title":"Automatic Error Trapping","text":"<p>When you call <code>logging::init</code>, the library automatically sets up error trapping:</p> <pre><code>#!/usr/bin/env bash\nsource ./logging.lib.sh\nlogging::init \"$0\"\n\n# Any command that fails will be automatically logged\nfalse  # This will trigger: \"Unexpected fatal error in script.sh on line 6: false\"\n</code></pre>"},{"location":"getting-started/#manual-error-handling","title":"Manual Error Handling","text":"<p>You can still handle errors manually when needed:</p> <pre><code>if ! risky_command; then\n    logging::log_error \"Risky command failed, but we'll continue\"\n    # Continue execution\nfi\n\n# Or for fatal errors\ncommand || logging::log_fatal \"Critical command failed\"\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>API Reference - Learn about all available functions</li> <li>Advanced Features - Understand trap chaining and technical details</li> <li>Examples - See real-world usage patterns</li> </ul>"},{"location":"getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/#common-issues","title":"Common Issues","text":"<p>\"This script requires Bash\" error:</p> <pre><code># Check your shebang line\n#!/usr/bin/env bash  # \u2713 Correct\n#!/bin/sh            # \u2717 Wrong\n</code></pre> <p>Perl not found: Install Perl on your system.</p> <p>Colors not working:</p> <ul> <li>Colors are automatically disabled in non-interactive environments</li> <li>To force colors: ensure your terminal supports ANSI codes</li> <li>To disable colors: redirect stderr to a file</li> </ul>"},{"location":"getting-started/#getting-help","title":"Getting Help","text":"<ul> <li>Check the examples for common patterns</li> <li>Review the API reference for detailed function docs</li> <li>Open an issue on GitHub for bugs or feature requests</li> </ul>"}]}